; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S < %s -mem2reg | FileCheck %s

declare void @foo1a(i8* readnone nocapture, i8) local_unnamed_addr
declare void @foo1b(i8* nocapture, i8) local_unnamed_addr readnone
declare void @foo1c(i8* nocapture, i8) local_unnamed_addr inaccessiblememonly

; Doesn't read from pointer argument, promotable
define i32 @a() norecurse {
; CHECK-LABEL: define {{[^@]+}}@a()
; CHECK-NEXT:    [[TMP1:%.*]] = alloca i32
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32* [[TMP1]] to i8*
; CHECK-NEXT:    call void @foo1a(i8* [[TMP2]], i8 0)
; CHECK-NEXT:    call void @foo1b(i8* [[TMP2]], i8 0)
; CHECK-NEXT:    call void @foo1c(i8* [[TMP2]], i8 0)
; CHECK-NEXT:    ret i32 42
;
  %g1 = alloca i32
  store i32 42, i32 *%g1
  %p = bitcast i32* %g1 to i8*
  call void @foo1a(i8* %p, i8 0)
  call void @foo1b(i8* %p, i8 0)
  call void @foo1c(i8* %p, i8 0)
  %a = load i32, i32* %g1
  ret i32 %a
}

declare void @foo2a(i8*, i8) local_unnamed_addr readnone
declare void @foo2b(i8* nocapture, i8) local_unnamed_addr

; May-capture and may-read, not promotable
define i32 @b() norecurse {
; CHECK-LABEL: define {{[^@]+}}@b()
; CHECK-NEXT:    [[G2:%.*]] = alloca i32
; CHECK-NEXT:    store i32 42, i32* [[G2]]
; CHECK-NEXT:    [[P:%.*]] = bitcast i32* [[G2]] to i8*
; CHECK-NEXT:    call void @foo2a(i8* [[P]], i8 0)
; CHECK-NEXT:    call void @foo2b(i8* [[P]], i8 0)
; CHECK-NEXT:    [[B:%.*]] = load i32, i32* [[G2]]
; CHECK-NEXT:    ret i32 [[B]]
;
  %g2 = alloca i32
  store i32 42, i32 *%g2
  %p = bitcast i32* %g2 to i8*
  call void @foo2a(i8* %p, i8 0)
  call void @foo2b(i8* %p, i8 0)
  %b = load i32, i32* %g2
  ret i32 %b
}

define i1 @is_aligned(i32* nocapture readnone) norecurse {
; CHECK-LABEL: define {{[^@]+}}@is_aligned
; CHECK-SAME: (i32* nocapture readnone [[TMP0:%.*]])
; CHECK-NEXT:    [[INT:%.*]] = ptrtoint i32* [[TMP0]] to i64
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[INT]], 31
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i64 [[AND]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %int = ptrtoint i32* %0 to i64
  %and = and i64 %int, 31
  %cmp = icmp ne i64 %and, 0
  ret i1 %cmp
}

; No non-bitcasts/qualifying calls, not promotable
define i1 @is_stack_aligned() norecurse {
; CHECK-LABEL: define {{[^@]+}}@is_stack_aligned()
; CHECK-NEXT:    [[VAR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[RET:%.*]] = call zeroext i1 @is_aligned(i32* nonnull [[VAR]])
; CHECK-NEXT:    ret i1 [[RET]]
;
  %var = alloca i32, align 4
  %ret = call zeroext i1 @is_aligned(i32* nonnull %var)
  ret i1 %ret
}

define i1 @is_same(i32* nocapture readnone, i16* nocapture readnone)  norecurse {
; CHECK-LABEL: define {{[^@]+}}@is_same
; CHECK-SAME: (i32* nocapture readnone [[TMP0:%.*]], i16* nocapture readnone [[TMP1:%.*]])
; CHECK-NEXT:    [[CAST:%.*]] = bitcast i16* [[TMP1]] to i32*
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32* [[CAST]], [[TMP0]]
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %cast = bitcast i16* %1 to i32*
  %cmp = icmp eq i32* %cast, %0
  ret i1 %cmp
}

; No non-bitcasts/qualifying calls, not promotable
define i1 @return_true() norecurse {
; CHECK-LABEL: define {{[^@]+}}@return_true()
; CHECK-NEXT:    [[VAR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[CAST:%.*]] = bitcast i32* [[VAR]] to i16*
; CHECK-NEXT:    [[RET:%.*]] = call zeroext i1 @is_same(i32* nonnull [[VAR]], i16* nonnull [[CAST]])
; CHECK-NEXT:    ret i1 [[RET]]
;
  %var = alloca i32, align 4
  %cast = bitcast i32* %var to i16*
  %ret = call zeroext i1 @is_same(i32* nonnull %var, i16* nonnull %cast)
  ret i1 %ret
}

declare void @llvm.trap()

; Bitcast dominates loads/stores, not promotable
define i32 @c() norecurse {
; CHECK-LABEL: define {{[^@]+}}@c()
; CHECK-NEXT:    [[VAR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[CAST:%.*]] = bitcast i32* [[VAR]] to i32*
; CHECK-NEXT:    store i32 42, i32* [[CAST]]
; CHECK-NEXT:    [[CAST2:%.*]] = bitcast i32* [[VAR]] to i16*
; CHECK-NEXT:    [[RET:%.*]] = call zeroext i1 @is_same(i32* nonnull [[VAR]], i16* nonnull [[CAST2]])
; CHECK-NEXT:    br i1 [[RET]], label [[CONT:%.*]], label [[TRAP:%.*]]
; CHECK:       trap:
; CHECK-NEXT:    call void @llvm.trap()
; CHECK-NEXT:    unreachable
; CHECK:       cont:
; CHECK-NEXT:    [[C:%.*]] = load i32, i32* [[CAST]]
; CHECK-NEXT:    ret i32 [[C]]
;
  %var = alloca i32, align 4
  %cast = bitcast i32* %var to i32*
  store i32 42, i32* %cast
  %cast2 = bitcast i32* %var to i16*
  %ret = call zeroext i1 @is_same(i32* nonnull %var, i16* nonnull %cast2)
  br i1 %ret, label %cont, label %trap
trap:
  call void @llvm.trap()
  unreachable
cont:
  %c = load i32, i32* %cast
  ret i32 %c
}

; Bitcast only dominates qualifying calls, promotable
define i32 @d() norecurse {
; CHECK-LABEL: define {{[^@]+}}@d()
; CHECK-NEXT:    [[TMP1:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32* [[TMP1]] to i16*
; CHECK-NEXT:    [[RET:%.*]] = call zeroext i1 @is_same(i32* nonnull [[TMP1]], i16* nonnull [[TMP2]])
; CHECK-NEXT:    br i1 [[RET]], label [[CONT:%.*]], label [[TRAP:%.*]]
; CHECK:       trap:
; CHECK-NEXT:    call void @llvm.trap()
; CHECK-NEXT:    unreachable
; CHECK:       cont:
; CHECK-NEXT:    ret i32 42
;
  %var = alloca i32, align 4
  store i32 42, i32* %var
  %cast = bitcast i32* %var to i16*
  %ret = call zeroext i1 @is_same(i32* nonnull %var, i16* nonnull %cast)
  br i1 %ret, label %cont, label %trap
trap:
  call void @llvm.trap()
  unreachable
cont:
  %d = load i32, i32* %var
  ret i32 %d
}
