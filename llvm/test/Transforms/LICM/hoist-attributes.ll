; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S < %s -licm | FileCheck %s

declare i32 @foo1a() readnone nounwind
declare i32 @foo1b(i8* readnone) readnone nounwind
declare i32 @foo1c(i8* readnone) nounwind

declare void @foo2a() inaccessiblememonly writeonly nounwind
declare void @foo2b(i8*) inaccessiblemem_or_argmemonly writeonly nounwind
declare void @foo2c(i8* readnone) inaccessiblememonly writeonly nounwind
declare void @foo2d(i8* writeonly) nounwind

@str = internal global [4 x i8] c"foo\00", align 1

declare noalias i8* @malloc()

; Functions that are nounwind and readnone (foo1a, foo1b) can be hoisted
define i32 @test1(i1 %c) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STR:%.*]] = getelementptr inbounds [4 x i8], [4 x i8]* @str, i64 0, i64 0
; CHECK-NEXT:    [[RET1A:%.*]] = call i32 @foo1a()
; CHECK-NEXT:    [[RET1B:%.*]] = call i32 @foo1b(i8* [[STR]])
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[SUM:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD1C:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[ADD1A:%.*]] = add nuw i32 [[SUM]], [[RET1A]]
; CHECK-NEXT:    [[ADD1B:%.*]] = add nuw i32 [[ADD1A]], [[RET1B]]
; CHECK-NEXT:    [[RET1C:%.*]] = call i32 @foo1c(i8* [[STR]])
; CHECK-NEXT:    [[ADD1C]] = add nuw i32 [[ADD1B]], [[RET1C]]
; CHECK-NEXT:    br i1 [[C:%.*]], label [[LOOP]], label [[OUT:%.*]]
; CHECK:       out:
; CHECK-NEXT:    [[ADD1C_LCSSA:%.*]] = phi i32 [ [[ADD1C]], [[LOOP]] ]
; CHECK-NEXT:    ret i32 [[ADD1C_LCSSA]]
;
entry:
  %str = getelementptr inbounds [4 x i8], [4 x i8]* @str, i64 0, i64 0
  br label %loop
loop:
  %sum = phi i32 [ 0, %entry ], [ %add1c, %loop ]
  %ret1a = call i32 @foo1a()
  %add1a = add nuw i32 %sum, %ret1a
  %ret1b = call i32 @foo1b(i8* %str)
  %add1b = add nuw i32 %add1a, %ret1b
  %ret1c = call i32 @foo1c(i8* %str)
  %add1c = add nuw i32 %add1b, %ret1c
  br i1 %c, label %loop, label %out
out:
  ret i32 %add1c
}

; Only writes to inaccessible or argument memory (foo2a, foo2b, foo2c), can all
; be hoisted since arguments don't alias or aren't accessed
define void @test2abc(i1 %c) {
; CHECK-LABEL: @test2abc(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[MEM:%.*]] = call noalias i8* @malloc()
; CHECK-NEXT:    [[STR:%.*]] = getelementptr inbounds [4 x i8], [4 x i8]* @str, i64 0, i64 0
; CHECK-NEXT:    call void @foo2a()
; CHECK-NEXT:    call void @foo2b(i8* [[MEM]])
; CHECK-NEXT:    call void @foo2c(i8* [[STR]])
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[LOOP]], label [[OUT:%.*]]
; CHECK:       out:
; CHECK-NEXT:    ret void
;
entry:
  %mem = call noalias i8* @malloc()
  %str = getelementptr inbounds [4 x i8], [4 x i8]* @str, i64 0, i64 0
  br label %loop
loop:
  call void @foo2a()
  call void @foo2b(i8* %mem)
  call void @foo2c(i8* %str)
  br i1 %c, label %loop, label %out
out:
  ret void
}

; May read/write memory that could alias (foo2d), can't be hoisted
define void @test2d(i1 %c) {
; CHECK-LABEL: @test2d(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STR:%.*]] = getelementptr inbounds [4 x i8], [4 x i8]* @str, i64 0, i64 0
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    call void @foo2d(i8* [[STR]])
; CHECK-NEXT:    br i1 [[C:%.*]], label [[LOOP]], label [[OUT:%.*]]
; CHECK:       out:
; CHECK-NEXT:    ret void
;
entry:
  %str = getelementptr inbounds [4 x i8], [4 x i8]* @str, i64 0, i64 0
  br label %loop
loop:
  call void @foo2d(i8* %str)
  br i1 %c, label %loop, label %out
out:
  ret void
}
